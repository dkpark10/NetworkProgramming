# TCP 내부 동작원리 

### 상대소켓과의 연결

TCP 소켓 생성 소멸과정은 다음과 같다.

1. 상대소켓과의 연결
2. 상대 소켓과의 데이터 송수신
3. 상대 소켓과의 연결종료

TCP 소켓은 연결설정 과정에서 총 세 번 대화를 주고 받는다. 

![](C:\Users\userpc\Desktop\3hand.PNG)

소켓은 전 이중방식으로 동작하므로 양방향으로 데이터를 주고받을 수 있다.
따라서 데이터 송수신에 앞서 준비과정이 필요하다. 

클라이언트는 서버에 SYN을 보낸다. 처음 연결요청에 보내는 메세지를 가리켜 SYN이라 한다.

이제 서버는 클라이언트에게 **SYN + ACK**를 보낸다 이는처음 클라가 전송한 패킷에 대한 응답메시지와 함께 서버의 데이터 전송을 위한 동기화 메시지를 함꼐 묶어 보내고 있다.

이렇듯 데이터 송수신에 앞서 송수신에 사용하는 패킷에 번호를 부여하고 이 번호정보를 상대방에게 알리는 이유는 데이터 손실을 막기 위함이다. 패킷번호를 부여해 확인하는 절차는 손실된 데이터 확인 및 재전송이 가능하고 때문에 TCP는 손실없는 데이터 전송을 보장한다. 

그 다음은 전에 전송한 패킷을 받았다는 확인과 ACK메세지를 전송한다. 이로서 데이터 송수신 준비가 모두 되었음을 서로 인식한다. 

### 상대 소켓과의 데이터 송수신

![](C:\Users\userpc\Desktop\cc.png)

위 그림은 호스트 A가 B에게 총 200바이트를 두번에 나눠 전송하는 과정이다. 먼저 100바이트를 하나 실어 전송하고 패킷의 SEQ를 1200으로 부여한다. 때문에 호스트 B는 이를 근거로 패킷이 제대로 수신되었음을 알려야 한다. 그래서 ACK1301 메세지를 담은 패킷을 A에게 전송한다.  1201이 아닌 1301은 데이터 바이트 크기만큼 추가로 증가시켜서이다. 이로서 100바이트를 온전히 수신하였는지 아닌지 알 수 있다. 다음 공식을 기준으로 ACK메세지를 전송한다.

> ACK num  ->  SEQ num + 전송된 바이트크기 + 1

![](C:\Users\userpc\Desktop\dd.png)

다음은 데이터 송신오류 과정이다. SEQ 1301인 패킷에 100바이트를 B로 전송되는데 오류로 인해 실패했다. 이 경우 A는 일정시간이 지나도 SEQ1301에 대한 ACK를 받지 못하기 때문에 재전송을 한다. 데이터 손실에 대한 재전송을 위해 TCP 소켓은 ACK응답을 요구하는 패킷 전송 시에 타이머를 동작시킨다. 그리고 해당타이머의 타임아웃시 패킷을 재전송한다. 

### 상대 소켓과 연결종료

![](C:\Users\userpc\Desktop\end.png)

종료과정은 네번 거친다. 