# TCP/IP 기반 기초구현 

TCP/IP 서버에서의 기초적인 함수 호출 순서이다. </br>

![image](https://user-images.githubusercontent.com/43857226/78007608-7c305200-7379-11ea-84b3-9b5256983e49.png)

소켓함수호출을 통해 소켓을 생성 소켓에 주소정보를 담기위해 구조체 변수 </br>
선언 및 초기화 바인드함수호출을 통하여 소켓에 주소를 할당한다.</br>

### 연결요청 대기상태로의 진입

바인드함수 호출을 통해 소켓에 주소까지 할당하였다면 리슨함수를 통해 연결요청 대기상태로 </br>
들어가야 한다. 그리고 **리슨함수가 호출되어야만 클라이언트가 연결요청을 할 수 있는 상태가된다.** </br>

```c++
int listen(int sockfd, int backlog);
성공시 0 실패시 -1 
```
처음인자는 소켓의 파일디스크립터를 전달 이 함수의 인자로 전달된 소켓이 서버소켓이 된다. </br>
두번째인자는 연결요청 대기큐의 크기를 전달 8을 전달하면 연결요청을 8까지 대기시킬 수 있다. </br>
서버가 연결요청대기상태에 있다는 것은 클라가 요청할 때 연결 수락될 때 까지 연결요청 자체를 </br>
대기시킬 수 있는 상태에 있다는 것을 의미한다. </br>

![image](https://user-images.githubusercontent.com/43857226/78008144-43dd4380-737a-11ea-8102-ce3111da7226.png)

클라의 연결요청도 인터넷을 통해 들어온 일종의 데이터 전송이기 때문에 이것을 받아들이려면 </br>
**소켓이 하나 있어야 한다.** 서버소켓은 일종의 문지기 역할을 한다고 볼 수 있다. </br>
마치 은행장구라고나 할까 은행원이 서버소켓이다. 리슨함수가 호출되면 서버소켓이 만들어지고 </br>
두번째 인자의 크기만큼 대기실이 만들어진다. 이 대기실을 가리켜 **연결요청대기 큐** 라 한다. </br>
두번쨰 인자는 보통 **15** 이상을 전달한다. 이것이 국룰~~~~~~~~~~~~~~~~~~</br> 

### 클라이언트의 연결요청 수락

리슨함수 호출 이후 클라의 연결요청이 들어왔다면 들어온 순서대로 수락해야한다. 마치 큐 </br>
연결요청 수락은 클라와 데이터를 주고받을 수 있는 상태가 됨을 의미한다. </br>
이러한 상태가 되기 위해서 당연히 소켓이 필요하다. 데이터를 주고받는데 당연 소켓이다. </br>
그런데 서버소켓은 문지기 역할이다. 클라이언트와 데이터 송수신을 위해 서버소켓을 사용한다면 </br>
문지기 역할은 누가 하는가???? 때문에 **소켓을 하나 더 만들어야 한다.** </br>
벗 소켓을 직접만들 필요는 없다. 다음 함수 결과로 **소켓이 만들어지고 클라소켓과 자동으로 연결된다.** </br>


```c++ 
int accept(int sock, struct sockaddr* addr, socklen_t* addrlen);
성공시 소켓 파일디스크립터 전달 실패시 -1반환
```

1. 서버소켓 파일디스크립터 전달
2. 연결요청한 클라의 주소정보를 담을 변수의 주소 값 전달. 함수호출이 완료되면
인자로 전달된 주소의 변수에는 클라의 주소정보가 채워진다.
3. 두번째 매개변수에 전달된 주소변수크기를 바이트단위로 전달 단 크기 정보를 변수에 저장한 다음
변수의 주소값을 전달한다. 함수호출이 완료되면 크기정보로 채워져 있던 변수에는 클라의 주소정보 길이가 바이트
단위로 계산되어 채워진다. 

어셉트 함수는 연결요청 대기 큐에서 대기중인 클라 연결요청을 수락하는 기능의 함수다. </br>
따라서 어셉트 함수 호출성공 시 내부적으로 데이터 **입출력에 사용할 소켓**을 생성하고 </br>
그 소켓의 파일디스크립터를 리턴한다. 중요한 점은 **소켓이 자동으로 생성** 연결요청한 </br>
클라소켓에 연결까지 이루어진다는 점이다!!!!!!!. 다음 그림은 어셉트 함수 호출시 일어나는 상황 </br>

![image](https://user-images.githubusercontent.com/43857226/78009527-23ae8400-737c-11ea-8081-e2f2b4039386.png)

대기큐에 대기하던 연결요청 하나를 꺼내 새로운 소켓을 자동으로 생성 후 연결요청한다. </br>
이렇듯 서버에서 별도로 생성한 소켓과 클라 소켓이 직접 연결되었다. </br>

### 클라이언트 기본 함수호출 순서

클라는 서버에 비해 간단 소켓 생성하고 연결 요청하면 시마이 </br>

![image](https://user-images.githubusercontent.com/43857226/78010904-e0edab80-737d-11ea-92eb-4e3f9ce5d5d6.png)

커넥트 함수는 서버로 연결요청하는 함수이다. 서버는 리슨함수 호출 후 연결요청 대기 큐 </br>
를 만들어 놓는다. 따라서 그 이후부터 클라 연결요청을 할 수 있다. 그렇담 클라는  어찌 연결요청할까? </br>

```c++
int connect(int sock, struct sockaddr* sdrvaddr, socklen_t addrlen);
// 성공시 0 실패시 -1 반환
```

1. 클라 소켓 파일디스크립터 전달
2. 연결요청 할 서버의 주소정보를 담은 변수의 주소 값 전달 
3. 두번쨰 매개변수 바이트 단위 크기

클라 함수가 호출되면 다음 두가지 상황 중 한가지가 되어야 함수가 반환된다. </br>

1. 서버에 의해 연결요청이 접수되었다.
2. 네트워크 단절 등 오류가 발생해 연결요청 중단되었다.

여기서 커넥트 함수는 클라의 연결요청 정보가 서버의 연결요청 대기 큐에 등록된 상황을 의미한다. </br>
커넥트가 반환됬다 하더라도 당장 서비스가 이뤄지지 않음을 기억하도록 하자 !!!!! </br>
**클라 프로그램은 커넥트 함수 내부에서 자동으로 아이피와 포트를 할당해준다. !!!** </br>

### TCP기반 서버 클라 함수 호출관계

서버는 바인드 , 리슨 호출을 통해 대기상태에 들어가고 클라는 커넥트 함수호출을 통해 들어간다. </br>
**특히 클라는 서버소켓의 리슨함수 호출 이후 커넥트 함수 호출이 가능하다 !!!! </br>
